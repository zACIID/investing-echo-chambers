---
title: "Network and sentiment visualizations for r/wallstreetbets"
author: "Pierluigi Marchioro"
date: "21/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(digest)
library(dplyr)
library(ggplot2)
library(ggraph)
library(igraph)
library(graphlayouts)
library(hrbrthemes)
```


```{r plot_styling}
edge.color <- "#cacac0"
#density.border <- "#5c3da6"
#density.fill <- "#8871bf"
density.border <- "#ff7512"
density.fill <- "#ffa500"
density.fill.alpha <- 0.5
mean_line.color <- "darkred"
titles.size <- 15
# Dark red, red, light red, light green, green, dark green
bear_bull_color_scale <- c("#8a0007", "#d9000c", "#fa6b73", "#add6a7", "#6db064", "#127a04")
```



# Load datasets

```{r}
# Col-names: user, text, interacted_with
interactions <- fread("../datasets/wsb-interactions.csv", sep=",", header=TRUE)
dim(interactions)
head(interactions)
```

```{r}
# Col-names: text, sentiment_score
text.sentiment <- fread("../datasets/wsb-text-sentiment.csv", sep=",", header=TRUE)
dim(text.sentiment)
head(text.sentiment)
```

```{r}
# Col-names: user, sentiment_score
user.sentiment <- fread("../datasets/wsb-user-sentiment.csv", sep=",")
dim(user.sentiment)
head(user.sentiment)
```

# Data cleaning and pre-processing

## Remove moderator bots

```{r}
# AutoModerator, VisualMod
bot_mods <- c("VisualMod", "AutoModerator")

interactions = interactions[!(user %in% bot_mods | interacted_with %in% bot_mods), ]
dim(interactions)

user.sentiment = user.sentiment[!(user %in% bot_mods), ]
dim(user.sentiment)
```

## Drop data that is either empty or na

```{r}
interactions <- na.omit(interactions)
interactions <- interactions[(user != "" & interacted_with != ""), ]

text.sentiment <- na.omit(text.sentiment)
text.sentiment <- text.sentiment[(text != ""), ]

user.sentiment <- na.omit(user.sentiment)
user.sentiment <- user.sentiment[(user != ""), ]
```


## Anonymize usernames

```{r}
# TODO makes everything heavier and causes errors, need to remove

#anonymize <- function(data, cols_to_anon, algo = "sha256"){
#    if(!require(digest)) stop("digest package is required")
#    to_anon <- subset(data, select = cols_to_anon)
#    unname(apply(to_anon, 1, digest, algo = algo))
#}
#
#user.sentiment$user <- anonymize(user.sentiment, "user")
#head(user.sentiment)
#
#interactions$user <- anonymize(interactions, "user")
#interactions$interacted_with <- anonymize(interactions, "interacted_with")
#head(interactions)
```



# Distribution of text sentiment 

```{r}
# density plot
ggplot(text.sentiment, aes(x=sentiment_score)) +
    geom_density(color=density.border, fill=density.fill, alpha=density.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment_score)), color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across r/wallstreetbets text data") +
    theme_ft_rc(plot_title_size=titles.size) +
    labs(x="sentiment", y="frequency")
```



# Distribution of user sentiment

```{r}
# density plot
ggplot(user.sentiment, aes(x=sentiment_score)) +
    geom_density(color=density.border, fill=density.fill, alpha=density.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment_score)), color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across r/wallstreetbets users") +
    theme_ft_rc(plot_title_size=titles.size) +
    labs(x="sentiment", y="frequency")
```



# Visualize Network

## Create user network graph

```{r}
# Prepare interactions data for igraph (first two columns define how edges are made)
user_edges.dt <- interactions[, c("user", "interacted_with")]
user.network <- graph_from_data_frame(user_edges.dt, directed=FALSE)

# Remove multiple edges (one user may interact with another user more than once)
user.network <- simplify(user.network)
head(E(user.network))
```
```{r}
# Set sentiment attribute in the vertexes
sentiment.with_order <- user.sentiment[as.character(user) %in% as.character(V(user.network)$name)]
sentiment.with_order <- sentiment.with_order[order(match(user, V(user.network)$name))]
user.network <- set_vertex_attr(user.network, "sentiment", 
                                index = V(user.network)[as.character(name) %in% as.character(sentiment.with_order$user)], 
                                sentiment.with_order$sentiment_score)
```

```{r}
# TODO does it make sense to plot such a large network?
# Plain network plot, no sentiment info
#ggraph(user.network, layout="randomly") + 
#    geom_edge_link(color=edge.color) +
#    geom_node_point(aes(color=as.factor(name))) +
#    theme(legend.position="none")
```

```{r}
# TODO ultra heavy
# Plot network graph with sentiment data
#ggraph(user.network, layout="grid") + 
#    geom_edge_link(color=edge.color) +
#    geom_node_point(aes(color=sentiment)) +
#    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1))
#
#ggraph(user.network, layout="circle", order=order(V(user.network)$sentiment)) + 
#    geom_edge_link(color=edge.color) +
#    geom_node_point(aes(color=sentiment)) +
#    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1))
```


## Community Detection

Good summary of various igraph algorithms:
[link to stackoverflow](https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph)

I chose multilevel because it is the fastest and I have limited hardware.

```{r}
# Remove isolated vertices to speed up the process and not clutter the network
# with meaningless communities
user.isolated <- which(degree(user.network)==0)
user.network <- delete.vertices(user.network, user.isolated)

communities <- multilevel.community(user.network)
V(user.network)$community <- communities$membership
```

### Calculate communities characteristics

```{r}
# Create a data.table that represents the user network's vertexes
vertex.dt <- data.table(
    name=V(user.network)$name,
    community=V(user.network)$community,
    sentiment=V(user.network)$sentiment
)

# Create a data.table of community edges from the user network vertexes
community_edges.dt <- merge.data.table(vertex.dt, user_edges.dt, by.x=c("name"), by.y="user")
community_edges.dt <- merge.data.table(vertex.dt, community_edges.dt, by.x=c("name"), by.y="interacted_with")
community_edges.dt <- community_edges.dt[, c("community.x", "community.y")]
colnames(community_edges.dt) <- c("from_community", "to_community")

# Calculate characteristics
# Create data.table pairing communities with their size and sentiment
communities.dt <- vertex.dt[, .(size=.N, sentiment=mean(sentiment)), by=c("community")]
communities.dt <- unique(communities.dt[, c("community", "size", "sentiment")])
```

### Create and plot communities network graph

```{r}
# Create communities graph
communities.network <- graph_from_data_frame(community_edges.dt, directed=FALSE)
communities.network <- simplify(communities.network)

# Need to order the communities before assigning attributes to vertexes,
# else the values to assign "aren't aligned" with the vertexes they should go to
comm.with_order <- communities.dt[as.character(community) %in% as.character(V(communities.network)$name)]
comm.with_order <- comm.with_order[order(match(community, V(communities.network)$name))]

# Assign size and sentiment attributes to network vertexes
communities.network <- set_vertex_attr(communities.network, "size", 
                                       index = V(communities.network)[as.character(name) %in% as.character(comm.with_order$community)], 
                                       comm.with_order$size)
```

```{r}
# Community network plot
ggraph(communities.network, layout="kk") + 
    geom_edge_link(color=edge.color) +
    geom_node_point(aes(color=as.factor(name), size=size)) +
    theme(legend.position="none")
```

## Communities Sentiment

### Network graph

```{r}
# Add sentiment attribute to community vertexes
communities.network <- set_vertex_attr(communities.network, "sentiment", 
                                       index = V(communities.network)[as.character(name) %in% as.character(comm.with_order$community)], 
                                       comm.with_order$sentiment)
```

```{r}
# Plot network with sentiment information
ggraph(communities.network, layout="kk") + 
    geom_edge_link(color=edge.color) +
    geom_node_point(aes(color=sentiment, size=size)) +
    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1))

ggraph(communities.network, layout="circle", order=order(V(communities.network)$sentiment)) + 
    geom_edge_link(color=edge.color) +
    geom_node_point(aes(color=sentiment, size=size)) +
    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1))
```

### Sentiment distribution

```{r}
# density plot
ggplot(communities.dt, aes(x=sentiment)) +
    geom_density(color=density.border, fill=density.fill, alpha=density.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment)), color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across r/wallstreetbets communities") +
    theme_ft_rc(plot_title_size=titles.size) +
    labs(x="sentiment", y="frequency")

# Bar plot (x=community, y=size, color=sentiment)
# Basic density
#to_plot <- communities.dt[size > 25, ]
#to_plot <- to_plot[order(sentiment)]
#ggplot(to_plot, aes(x=reorder(community, sentiment), y=size, fill=sentiment)) + 
#    scale_fill_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1)) +
#    geom_bar(stat="identity") +
#    #geom_histogram(aes(y=..density..), alpha=0.7) +
#    #geom_density() +
#    geom_vline(aes(xintercept=mean(sentiment)),
#               color="darkred", linetype="dashed", size=1) +
#    theme_classic()
#
#ggplot(to_plot, aes(x=sentiment, fill=sentiment)) + 
#    scale_fill_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1)) +
#    #(stat="identity") +
#    #geom_histogram(aes(y=..density..), alpha=0.7) +
#    geom_density() +
#    geom_vline(aes(xintercept=mean(sentiment)),
#               color="darkred", linetype="dashed", size=1) +
#    theme_classic()
```


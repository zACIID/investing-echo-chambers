---
title: "Network and sentiment visualizations for r/wallstreetbets"
author: "Pierluigi Marchioro"
date: "21/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(dplyr)
library(ggplot2)
library(ggraph)
library(igraph)
library(graphlayouts)
library(hrbrthemes)  # plot themes
library(manipulate)  # add #points to density raster

getwd()
```

```{r style}
# Density plots style
density.border <- "#ff7512"
density.fill <- "#ffa500"
density.fill.alpha <- 0.5

density.hist.border <- "black"
density.hist.fill <- "white"
density.hist.fill.alpha <- 0.2

mean_line.color <- "darkred"
titles.size <- 15

# 2d Density raster style
density.2d.palette <- "magma"
density.2d.raster_points <- 250

# Graph plots style
edge.color <- "#626466"
edge.color.no <- NA

# Dark red, red, yellow-orange, green, dark green
bear_bull_color_scale <- c("#8a0007", "#d9000c", "#ded83c", "#71cc2b", "#127a04")
```

```{r setup_img_dir}
VISUALIZATIONS_DIR <- "../visualizations"

#!dir.exists(file.path(mainDir, subDir)), dir.create(file.path(mainDir, subDir)), FALSE)
if (!dir.exists(VISUALIZATIONS_DIR)) {
  dir.create(VISUALIZATIONS_DIR)
  print(paste0("created dir at: ", VISUALIZATIONS_DIR))
}
```

```{r img_save_params}
# ggsave parameters used to save visualizations into images
img.type <- "png"
img.height <- 9  # inches
img.width <- 12  # inches
img.dpi <- 700
```


# Load datasets

```{r}
# Col-names: user, text, interacted_with
interactions <- fread("../datasets/interactions.csv", sep=",", header=TRUE)
dim(interactions)
head(interactions)
```

```{r}
# Col-names: text, sentiment_score
text.sentiment <- fread("../datasets/text-sentiment.csv", sep=",", header=TRUE)
dim(text.sentiment)
head(text.sentiment)
```

```{r}
# Col-names: user, sentiment_score
user.sentiment <- fread("../datasets/user-sentiment.csv", sep=",")
dim(user.sentiment)
head(user.sentiment)
```

# Data cleaning and pre-processing

## Make sure data-types are correct

```{r}
# Do it just for sentiment scores, since they will be plotted.
# Must make sure they are of numeric type, else they will be plotted as discrete values
user.sentiment <- user.sentiment[, sentiment_score:=as.double(sentiment_score)]
head(user.sentiment)

text.sentiment <- text.sentiment[, sentiment_score:=as.double(sentiment_score)]
head(text.sentiment)
```


## Drop data that is either empty or na

```{r}
interactions <- na.omit(interactions)
interactions <- interactions[(user != "" & interacted_with != ""), ]

text.sentiment <- na.omit(text.sentiment)
text.sentiment <- text.sentiment[(text != ""), ]

user.sentiment <- na.omit(user.sentiment)
user.sentiment <- user.sentiment[(user != ""), ]
```


## Attempt to remove spam (TO REMOVE)

```{r}
## numero determinato a seguito di un'analisi dei dati sullo spam. 
## Sotto questo numero è possibile che siano inclusi anche utenti che hanno usato 
## un paio di volte la stessa faccina o risposto con frasi tipo "thanks", "lol", "xd", etc.
## 4 che tra l'altro è il 3° quartile in termini di spam_count
#spam.threshold <- 4
#
## Compute a data.table containing the amount of spam texts that a user has created
## This is done by first grouping by (user, text) and extracting tuples whose spam_count >= 2
## (which means that a unique message was sent more than 1 time)
#spam <- copy(interactions)
#spam <- spam[, spam_count:=.N, by=.(user, text)]
#spam <- spam[spam_count >= spam.threshold,]
#
## Then, such pairs are grouped by user, so that the the sum of spam texts
## that a user has created can be effectively calculated
#spam.by_user <- distinct(spam, user, text, .keep_all=TRUE)
#spam.by_user <- spam.by_user[, spam_count:=lapply(.SD, sum), by=.(user), .SDcols = c("spam_count")]
#summary(spam.by_user)
#
#```
#
#
#```{r}
# TODO Ora provo a vedere cosa succede se rimuovo interazioni, utenti e testi di utenti con spam_count >= 4.
# rimuovo da interazioni dove creatore è utente spam, testi presenti tra i testi spam e poi data table utenti azzero sentiment.
# Azzero il sentiment perché sono probabilmente dei bot che spammano però mi serve un dato
# sul sentiment per poterli plottare
#
#spam.users <- spam.by_user[spam_count >= spam.threshold, user]
#spam.users <- unique(spam.users)
#
#spam.texts <- spam[spam_count >= spam.threshold, text]
#spam.texts <- unique(spam.texts)
#```
#
#```{r}
#interactions <- interactions[!(user %in% spam.users), ]
#text.sentiment <- text.sentiment[!(text %in% spam.texts), ]
#user.sentiment <- user.sentiment[user %in% spam.users, sentiment_score:=0]
```



# Distribution of text sentiment 

```{r}
# density plot
ggplot(text.sentiment, aes(x=sentiment_score)) +
    geom_density(color=density.border, fill=density.fill, alpha=density.fill.alpha) +
    geom_histogram(aes(y=..density..), colour=density.hist.border, 
                   fill=density.hist.fill, alpha=density.hist.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment_score)), 
               color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across text data") +
    theme_ft_rc(plot_title_size=titles.size) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank()) +
    labs(x="sentiment", y="density")

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="text-sentiment-distr.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```



# Distribution of user sentiment

```{r}
# density plot
ggplot(user.sentiment, aes(x=sentiment_score)) +
    geom_density(color=density.border, fill=density.fill, alpha=density.fill.alpha) +
    geom_histogram(aes(y=..density..), colour=density.hist.border, 
                   fill=density.hist.fill, alpha=density.hist.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment_score)), 
               color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across users") +
    theme_ft_rc(plot_title_size=titles.size) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank()) +
    labs(x="sentiment", y="density")

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="user-sentiment-distr.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```



# Visualize Network

## Create user network graph

```{r}
# Prepare interactions data for igraph (first two columns define how edges are made)
user_edges.dt <- interactions[, c("user", "interacted_with")]
user.network <- graph_from_data_frame(user_edges.dt, directed=FALSE)

# Remove multiple edges and loops (one user may interact with another user more than once)
user.network <- simplify(user.network)
head(E(user.network))
```

### User sentiment

```{r}
# Set sentiment attribute in the vertexes
# The indexes have to be aligned with the sentiment data
sentiment.with_order <- user.sentiment[as.character(user) %in% as.character(V(user.network)$name)]
sentiment.with_order <- sentiment.with_order[order(match(user, V(user.network)$name))]
set_idx <- V(user.network)[as.character(name) %in% as.character(sentiment.with_order$user)]
user.network <- set_vertex_attr(user.network, "sentiment", index = set_idx, 
                                sentiment.with_order$sentiment_score)
```

```{r}
## Plot circular network to better understand how sentiment is distributed across vertexes
#ggraph(user.network, layout="kk") + 
#    geom_edge_link(color=edge.color) +
#    geom_node_point(aes(color=sentiment)) +
#    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1))
#
## Save plot as image
#ggsave(path=VISUALIZATIONS_DIR, filename="user-sentiment-test.png", device=img.type,
#       width=img.width, height=img.height, dpi=img.dpi)
```


## Community Detection

Good summary of various igraph algorithms:
[link to stackoverflow](https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph)

I chose multilevel because it is the fastest and I have limited hardware.

```{r}
# Remove isolated vertices to speed up the process and not clutter the network
# with meaningless communities
user.isolated <- which(degree(user.network)==0)
user.network <- delete.vertices(user.network, user.isolated)

communities <- multilevel.community(user.network)
V(user.network)$community <- communities$membership
```

### Calculate communities characteristics

```{r}
# Create a data.table that represents the user network's vertexes
vertex.dt <- data.table(
    name=V(user.network)$name,
    community=V(user.network)$community,
    sentiment=V(user.network)$sentiment
)

# Create a data.table of community edges from the user network vertexes
community_edges.dt <- merge.data.table(vertex.dt, user_edges.dt, 
                                       by.x=c("name"), by.y="user")

community_edges.dt <- merge.data.table(vertex.dt, community_edges.dt, 
                                       by.x=c("name"), by.y="interacted_with")

community_edges.dt <- community_edges.dt[, c("community.x", "community.y")]
colnames(community_edges.dt) <- c("from_community", "to_community")

# Calculate characteristics
# Create data.table pairing communities with their size and sentiment
communities.dt <- vertex.dt[, .(size=.N, sentiment=mean(sentiment)), by=c("community")]
communities.dt <- unique(communities.dt[, c("community", "size", "sentiment")])
```

### Create and plot communities network graph

```{r}
# Create communities graph
communities.network <- graph_from_data_frame(community_edges.dt, directed=FALSE)
communities.network <- simplify(communities.network)

# Need to order the communities before assigning attributes to vertexes,
# else the values to assign "aren't aligned" with the vertexes they should go to
comm.with_order <- communities.dt[as.character(community) 
                                  %in% as.character(V(communities.network)$name)]

comm.with_order <- comm.with_order[order(match(community, V(communities.network)$name))]

# Assign size and sentiment attributes to network vertexes
set_idx <- V(communities.network)[as.character(name) %in% as.character(comm.with_order$community)]
communities.network <- set_vertex_attr(communities.network, "size",index = set_idx, 
                                       comm.with_order$size)
```

```{r}
# Community network plot
ggraph(communities.network, layout="kk") + 
    geom_edge_link(color=edge.color) +
    geom_node_point(aes(color=as.factor(name), size=size)) +
    ggtitle("Communities Network") +
    theme_ft_rc(plot_title_size=titles.size, 
                grid=FALSE) +
    theme(legend.position="none",
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank())

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-net.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```


## Communities Sentiment

### Network graph

```{r}
# Add sentiment attribute to community vertexes
set_idx <- V(communities.network)[as.character(name) %in% as.character(comm.with_order$community)]
communities.network <- set_vertex_attr(communities.network, "sentiment", 
                                       index = set_idx, 
                                       comm.with_order$sentiment)
```

```{r}
# Plot network with sentiment information
ggraph(communities.network, layout="kk") + 
    geom_edge_link(color=edge.color) +
    geom_node_point(aes(color=sentiment, size=size)) +
    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1)) +
    ggtitle("Communities Network") +
    theme_ft_rc(plot_title_size=titles.size, 
                grid=FALSE) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank())

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-net-sentiment.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```

```{r}
# Plot circular network to better understand how sentiment is distributed across vertexes
ggraph(communities.network, layout="circle", order=order(V(communities.network)$sentiment)) + 
    geom_edge_link(color=edge.color.no) +
    geom_node_point(aes(color=sentiment, size=size)) +
    scale_colour_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1)) +
    ggtitle("Communities Network - Ordered by Sentiment") +
    theme_ft_rc(plot_title_size=titles.size, 
                grid=FALSE) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank())

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-net-sentiment-circle.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```

### Sentiment distribution

Only 95th percentile communities are shown for clarity reasons: the total number of communities is several hundreds.
We can see that sentiment is slightly bullish on average, since the colors range from orangish to almost dark green.

```{r}
# Bar plot of community sizes, colored by sentiment
min_size.percentile <- 95
min_size = floor(quantile(communities.dt$size, min_size.percentile / 100))
ggplot(communities.dt[size >= min_size,], aes(x=reorder(community, sentiment), 
                                             y=size, fill=sentiment)) + 
    scale_fill_gradientn(colors=bear_bull_color_scale, limits=c(-1, 1)) +
    geom_bar(stat="identity") +
    theme_ft_rc(grid=FALSE) +
    theme(axis.text.x=element_blank(),
          axis.ticks.x=element_blank()) +
    labs(x=paste0("community (size >= ", min_size.percentile, "th percentile)"), y="size")

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-size-sentiment.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```

Intuizione confermata dal plot della distribuzione

```{r}
# density plot
ggplot(communities.dt, aes(x=sentiment)) +
    geom_density(aes(y=..density..), color=density.border, 
                 fill=density.fill, alpha=density.fill.alpha) +
    geom_histogram(aes(y=..density..), colour=density.hist.border, 
                   fill=density.hist.fill, alpha=density.hist.fill.alpha) +
    geom_vline(aes(xintercept=mean(sentiment)), 
               color=mean_line.color, linetype="dashed", size=1) +
    ggtitle("Sentiment distribution across communities") +
    theme_ft_rc(plot_title_size=titles.size) +
    theme(axis.text.y=element_blank(),
          axis.ticks.y=element_blank()) +
    labs(x="sentiment", y="density")

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-sentiment-distr.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```



# Visualizing Echo Chambers

## User network

```{r}
user.network.data <- as_long_data_frame(user.network)
setDT(user.network.data)

user.nn_data <- rbind(user.network.data[from_name != to_name, 
                                        .(nn_sentiment=mean(to_sentiment, na.rm=TRUE), 
                                          sentiment=unique(from_sentiment)), 
                                        by=.(id=from_name)],
                      user.network.data[from_name != to_name,
                                        .(nn_sentiment=mean(from_sentiment, na.rm=TRUE),
                                          sentiment=unique(to_sentiment)),
                                        by=.(id=to_name)])

user.nn_data <- distinct(user.nn_data, id, .keep_all=TRUE)

# manipulate is needed for the "n" parameter, #points in the raster grid
manipulate(
  ggplot(user.nn_data[!is.na(sentiment) & !is.nan(nn_sentiment)], 
       aes(x=sentiment, y=nn_sentiment)) +
  stat_density_2d(aes(fill = ..density..), geom="raster", contour=FALSE, 
                  n=density.2d.raster_points) +
  lims(x=c(-1, 1), y=c(-1, 1)) +
  scale_fill_viridis(option=density.2d.palette) +
  theme_classic() +
  theme(legend.position="none") +
  labs(x="user sentiment", y="neighborhood sentiment")
)

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="user-nn-sentiment.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```


## Communities network

```{r}
communities.network.data <- as_long_data_frame(communities.network)
setDT(communities.network.data)

comm.nn_data <- rbind(communities.network.data[from_name != to_name, 
                                               .(nn_sentiment=mean(to_sentiment, na.rm=TRUE), 
                                                 sentiment=unique(from_sentiment)), 
                                               by=.(id=from_name)],
                      communities.network.data[from_name != to_name,
                                               .(nn_sentiment=mean(from_sentiment, na.rm=TRUE),
                                                 sentiment=unique(to_sentiment)),
                                               by=.(id=to_name)])

comm.nn_data <- distinct(comm.nn_data, id, .keep_all=TRUE)

# manipulate is needed for the "n" parameter, #points in the raster grid
manipulate(
  ggplot(comm.nn_data[!is.na(sentiment) & !is.nan(nn_sentiment)], 
       aes(x=sentiment, y=nn_sentiment)) +
  stat_density_2d(aes(fill = ..density..), geom="raster", contour=FALSE, 
                  n=density.2d.raster_points) +
  lims(x=c(-1, 1), y=c(-1, 1)) +
  scale_fill_viridis(option=density.2d.palette) +
  theme_classic() +
  theme(legend.position="none") +
  labs(x="community sentiment", y="neighborhood sentiment")
)

# Save plot as image
ggsave(path=VISUALIZATIONS_DIR, filename="community-nn-sentiment.png", device=img.type,
       width=img.width, height=img.height, dpi=img.dpi)
```


